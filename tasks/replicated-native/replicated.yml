###
### Stop the Replicated and Replicated-UI containers so we can install or upgrade them
###

## TODO: add proxy support
## TODO: add ipv6 support
## TODO: add airgap support

- name: Stop Replicated
  service:
    name: replicated
    state: stopped
  become: yes
  become_method: sudo

- name: Stop Replicated-UI
  service:
    name: replicated-ui
    state: stopped
  become: yes
  become_method: sudo

###
### Autodiscover existing settings and re-use envvars like DAEMON_TOKEN when present
###

- name: Discover daemon token
  shell: |
    . /etc/default/replicated && echo $DAEMON_TOKEN
  register: existing_daemon_token

- name: Create new daemon token
  shell: |
    head -c 128 /dev/urandom | tr -dc "a-zA-Z0-9" | fold -w 32 | head -n 1
  register: new_daemon_token
  when: existing_daemon_token.rc != 0 and replicated_daemon_token is not defined

- name: Set daemon token
  set_fact:
    daemon_token: '{{ existing_daemon_token.stdout | default(new_daemon_token.stdout) }}'
  when: daemon_token is not defined

###
### Create Replicated user and install the global alias 
###

- include: user.yml
- include: config.yml

- name: Create Replicated Alias
  template:
    src: ../templates/replicated.alias
    dest: /etc/replicated.alias
    mode: 0644
  become: yes
  become_method: sudo

- name: Add replicated alias to global bash.bashrc
  blockinfile:
    dest: /etc/bash.bashrc
    insertafter: EOF
    state: present
    block: |
      if [ -f /etc/replicated.alias ]; then
          . /etc/replicated.alias
      fi
  become: yes
  become_method: sudo

###
### Download Replicated and Replicated-UI images
###

- name: Download Replicated
  command: docker pull "quay.io/replicated/replicated:{{ replicated_release_channel }}-{{ replicated_version }}"
  become: yes
  become_method: sudo

- name: Tag Replicated
  command: docker tag "quay.io/replicated/replicated:{{ replicated_release_channel }}-{{ replicated_version }}" "quay.io/replicated/replicated:current"
  become: yes
  become_method: sudo

- name: Download Replicated UI
  command: docker pull "quay.io/replicated/replicated-ui:{{ replicated_release_channel }}-{{ replicated_version }}"
  become: yes
  become_method: sudo

- name: Tag Replicated UI
  command: docker tag "quay.io/replicated/replicated-ui:{{ replicated_release_channel }}-{{ replicated_version }}" "quay.io/replicated/replicated-ui:current"
  become: yes
  become_method: sudo

##
## Discover the CA file and mount it into Replicated and thus allowing updates to the host CA file to be
## reflected in the running Replicated (Replicated will need to be restarted after the change)
##

- name: Check for /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem
  stat:
    path: /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem
  register: ca1

- name: Check for /etc/pki/tls/certs/ca-bundle.crt
  stat:
    path: /etc/pki/tls/certs/ca-bundle.crt
  register: ca2

- name: Check for /etc/ssl/ca-bundle.pem
  stat:
    path: /etc/ssl/ca-bundle.pem
  register: ca3

- name: Check for /etc/pki/tls/cacert.pem
  stat:
    path: /etc/pki/tls/cacert.pem
  register: ca4

- name: Check for /etc/ssl/certs/ca-certificates.crt
  stat:
    path: /etc/ssl/certs/ca-certificates.crt
  register: ca5

- name: Choose /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem if exists
  set_fact: cert_file="/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem"
  when: ca1.stat.exists == True

- name: Choose /etc/pki/tls/certs/ca-bundle.crt if exists
  set_fact: cert_file="/etc/pki/tls/certs/ca-bundle.crt"
  when: ca1.stat.exists == True

- name: Choose /etc/ssl/ca-bundle.pem if exists
  set_fact: cert_file="/etc/ssl/ca-bundle.pem"
  when: ca1.stat.exists == True

- name: Choose /etc/pki/tls/cacert.pem if exists
  set_fact: cert_file="/etc/pki/tls/cacert.pem"
  when: ca1.stat.exists == True

- name: Choose /etc/ssl/certs/ca-certificates.crt if exists
  set_fact: cert_file="/etc/ssl/certs/ca-certificates.crt"
  when: ca5.stat.exists == True

- name: Set the CA flag
  set_fact: replicated_trusted_cert_mount="-v {{ cert_file }}:/etc/ssl/certs/ca-certificates.crt"
  when: cert_file is defined

- name: Skip the CA flag, no CA file found
  set_fact: replicated_trusted_cert_mount=""
  when: cert_file is not defined

###
### Set startup opts flags for REPLICATED and REPLICATED_UI
###

- name: Set the HTTP_PROXY flag
  set_fact:
    http_proxy_envvar: '-e HTTP_PROXY="{{ HTTP_PROXY }}"'
  when: HTTP_PROXY is defined

- name: Default to no HTTP_PROXY
  set_fact:
    http_proxy_envvar: ''
  when: HTTP_PROXY is not defined

- set_fact:
    registry_advertise_address_envvar: ''
    daemon_token_envvar: '-e DAEMON_TOKEN="{{ daemon_token }}"'
    airgap_envvar: ''

###
### Create the file to store the Replicated settings
###

- name: Create Replicated defaults in {{ confdir }}/replicated
  template:
    src: replicated_conf.j2
    dest: "{{ confdir }}/replicated"
  become: yes
  become_method: sudo
  
###
### Create the init scripts
###

- name: Create Replicated init file at /etc/init/replicated.conf
  template:
    src: replicated/upstart/replicated_service.j2
    dest: /etc/init/replicated.conf
  when: ansible_service_mgr == "upstart"
  become: yes
  become_method: sudo

- name: Create Replicated UI init file at /etc/init/replicated-ui.conf
  template:
    src: replicated/upstart/replicated_ui_service.j2
    dest: /etc/init/replicated-ui.conf
  when: ansible_service_mgr == "upstart"
  become: yes
  become_method: sudo

###
### Bind the Replicated and Replicated-UI serviecs back online
###

- name: Start Replicated
  service:
    name: replicated
    state: started
  become: yes
  become_method: sudo

- name: Start Replicated-UI
  service:
    name: replicated-ui
    state: started
  become: yes
  become_method: sudo

## TODO: add sysv init scripts
## TODO: add systemd init scripts
